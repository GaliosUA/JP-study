<div id="deck" deck_name="{{Deck}}"></div>
<!---------- Header ------------->
<header>
  <div id="top-container">
    <p id="stars"></p>
    {{FreqSort}}
  </div>
</header>

<main>
  <div id="template">
    <!--------- Vocab card ---------->
    {{^*IsSentenceCard}}
    <div lang="ja" class="show-furigana vocab">
      {{#Expression (furigana)}}{{furigana:Expression (furigana)}}{{/Expression (furigana)}}
      {{^Expression (furigana)}}{{Expression}}{{/Expression (furigana)}}
      {{#Hint}}
      <div id="hint">{{Hint}}</div>
      {{/Hint}}
    </div>
    <hr id="divider" />
    <div lang="ja" class="info">
      {{Expression (audio)}} {{Sentence (audio)}}
      <div id="pitch"></div>
      {{#PitchPosition}}
      <span id="pitch-tags" class="tags"> {{PitchPosition}} </span>
      {{/PitchPosition}} 【{{Expression}}】
    </div>
    <div lang="ja" id="main-def" class="popup">{{MainDefinition}}</div>
    <br />
    {{Image}}
    <br />
    <div lang="ja" class="sentence">
      {{#Sentence (furigana)}} {{furigana:Sentence (furigana)}} {{/Sentence (furigana)}}
      {{^Sentence (furigana)}} {{furigana:Sentence}} {{/Sentence (furigana)}}
    </div>
    {{#Translation}}
    <div id="translation" lang="en">{{hint:Translation}}</div>
    {{/Translation}} {{/*IsSentenceCard}}

    <!------- Sentence card --------->
    {{#*IsSentenceCard}}
    <div lang="ja" class="sentence-big">
      {{#Sentence (furigana)}} {{furigana:Sentence (furigana)}} {{/Sentence (furigana)}}
      {{^Sentence (furigana)}} {{furigana:Sentence}} {{/Sentence (furigana)}}
    </div>
    {{#Hint}}
    <div id="hint">{{Hint}}</div>
    {{/Hint}} {{#Translation}}
    <div id="translation" lang="en">{{hint:Translation}}</div>
    {{/Translation}}
    <hr id="divider" />
    <div lang="ja" class="info">
      {{Expression (audio)}} {{Sentence (audio)}}
      <div id="pitch"></div>
      {{#PitchPosition}}
      <span id="pitch-tags" class="tags"> {{PitchPosition}} </span>
      {{/PitchPosition}} 【{{Expression}}】
    </div>
    <div lang="ja" id="main-def" class="popup">{{MainDefinition}}</div>
    <br />
    {{Image}}
    <br />
    {{/*IsSentenceCard}}
  </div>

  <div id="extras">
    {{#MiscInfo}}
    <div style="text-align: center">
      <div lang="ja">
        <details>
          <summary>Misc. info</summary>
          <div class="popup" id="misc-info">
            === Details ===
            <br />
            {{MiscInfo}} {{#Frequency}}
            <br />
            == Frequency == {{Frequency}} {{/Frequency}}
          </div>
        </details>
      </div>
    </div>
    {{/MiscInfo}} {{#FullDefinition}}
    <div style="text-align: center">
      <div lang="ja">
        <details>
          <summary>Full definition</summary>
          <div class="popup" id="full-def">{{FullDefinition}}</div>
        </details>
      </div>
    </div>
    {{/FullDefinition}}
  </div>
</main>

<!----------- Footer ------------->
<footer>
  <div id="bot-container">
    {{#Tags}}
    <div lang="ja" id="tags-container">
      <div class="tags">{{Tags}}</div>
    </div>
    {{/Tags}}
    <div id="checkbox"><input type="checkbox" /></div>
  </div>
</footer>

<!----------- Scripts ------------>
<script>
  function isOdaka(pitchNumber) {
    const kana = `{{kana:Expression (furigana)}}` || `{{Expression (reading)}}`;
    return (
      kana !== null &&
      kana.replace(/[ャュョゃゅょ]/g, "").length === pitchNumber
    );
  }

  function getPitchColor(pitchPosition) {
    const colors = {
      heiban: "#1d9bf0",
      atamadaka: "red",
      nakadaka: "#f5751d",
      odaka: "#3bd16f",
    };

    if (pitchPosition === 0) {
      return colors.heiban;
    } else if (pitchPosition === 1) {
      return colors.atamadaka;
    } else if (pitchPosition > 1) {
      return isOdaka(pitchPosition) ? colors.odaka : colors.nakadaka;
    }
  }

  function paintTargetWord() {
    const pitchPositions = `{{PitchPosition}}`.match(/^\d+|\d+\b|\d+(?=\w)/g);
    if (pitchPositions === null) return;

    const pitchPosition = Number(pitchPositions[0]);
    const sentences = Array.from(
      document.querySelectorAll(".sentence, .sentence-big")
    );
    for (const sentence of sentences) {
      for (const targetWord of sentence.getElementsByTagName("b")) {
        targetWord.style.color = getPitchColor(pitchPosition);
      }
    }
  }

  function tweakHTML() {
    // Modify translation button label
    const tlButton = document.querySelector("#translation > a.hint");
    if (tlButton) {
      tlButton.innerText = "Show Translation";
    }

    // Split tags
    const tagsContainer = document.querySelector("#tags-container");
    const tags = `{{Tags}}`.split(" ");
    if (tagsContainer) {
      tagsContainer.innerHTML = "";
      for (tag of tags) {
        const tagElem = document.createElement("div");
        tagElem.className = "tags";
        tagElem.innerText = tag;
        tagsContainer.appendChild(tagElem);
      }
    }

    // Get stars
    const freq = `{{FreqSort}}`;
    const stars = document.getElementById("stars");
    if (freq === "") return;
    if (freq > 0 && freq < 1500) {
      stars.innerHTML = "★★★★★";
    } else if (freq >= 1500 && freq < 5000) {
      stars.innerHTML = "★★★★";
    } else if (freq >= 5000 && freq < 15000) {
      stars.innerHTML = "★★★";
    } else if (freq >= 15000 && freq < 30000) {
      stars.innerHTML = "★★";
    } else if (freq >= 30000 && freq < 60000) {
      stars.innerHTML = "★";
    } else {
      stars.innerHTML = "";
    }
    if (Number(freq) === 0) {
      document.getElementById("top-container").innerHTML = "";
    }

    // Toggle extras display
    const checkBox = document.querySelector("#checkbox > input[type=checkbox]");
    const extras = document.getElementById("extras");
    checkBox.addEventListener("change", (e) => {
      extras.style.display = checkBox.checked ? "block" : "none";
    });
    extras.style.display = checkBox.checked ? "block" : "none";
  }

  function groupMoras(kana) {
    let currentChar = "";
    let nextChar = "";
    const groupedMoras = [];
    const check = ["ャ", "ュ", "ョ", "ゃ", "ゅ", "ょ"];
    for (let i = 0; i < kana.length; i++) {
      currentChar = kana[i];
      nextChar = i < kana.length - 1 && kana[i + 1];
      if (check.includes(nextChar)) {
        groupedMoras.push(currentChar + nextChar);
        i += 1;
      } else {
        groupedMoras.push(currentChar);
      }
    }
    return groupedMoras;
  }

  function getPitchPattern(pitchPosition) {
    /*	0 = low
  	 	1 = high
  		2 = high to low */

    const kana = `{{kana:Expression (furigana)}}` || `{{Expression (reading)}}`;
    const moras = groupMoras(kana);
    let pattern = [];

    if (pitchPosition === 0) {
      // 平板
      pattern = Array(moras[0].length).fill("0");
      pattern = [...pattern, ...Array(kana.length - moras[0].length).fill("1")];
    } else if (pitchPosition === 1) {
      // 頭高
      pattern = moras[0].length === 2 ? ["1", "2"] : ["2"];
      pattern = [...pattern, ...Array(kana.length - moras[0].length).fill("0")];
    } else if (pitchPosition > 1) {
      if (isOdaka(pitchPosition)) {
        // 尾高
        pattern = Array(moras[0].length).fill("0");
        pattern = [
          ...pattern,
          ...Array(kana.length - moras[0].length - 1).fill("1"),
          "2",
        ];
      } else {
        // 中高
        let afterDrop = false;
        for (let i = 0; i < moras.length; i++) {
          if (i === 0) {
            pattern = [...pattern, ...Array(moras[0].length).fill("0")];
          } else if (i + 1 === pitchPosition) {
            pattern =
              moras[i].length === 2
                ? [...pattern, "1", "2"]
                : [...pattern, "2"];
            afterDrop = true;
          } else if (afterDrop) {
            pattern = [...pattern, ...Array(moras[i].length).fill("0")];
          } else {
            pattern = [...pattern, ...Array(moras[i].length).fill("1")];
          }
        }
      }
    }
    return pattern;
  }

  function constructPitch() {
    const kana = `{{kana:Expression (furigana)}}` || `{{Expression (reading)}}`;
    const pitch = document.getElementById("pitch");
    const pitchPositions = `{{PitchPosition}}`.match(/^\d+|\d+\b|\d+(?=\w)/g);
    if (!pitchPositions) {
      pitch.innerHTML = `<div style="margin-right: -15px; display: inline;">${kana}</div>`;
      return;
    }

    const pitchTags = document.getElementById("pitch-tags");
    let uniquePitchPositions = [...new Set(pitchPositions)];
    let hold = ``;
    let holdTags = `<ul>`;

    for (let pitchPosition of uniquePitchPositions) {
      if (pitchPosition !== uniquePitchPositions[0]) hold += `・`;

      holdTags += `<li>${pitchPosition}</li>`;

      const pattern = getPitchPattern(Number(pitchPosition));
      const color = getPitchColor(Number(pitchPosition)) || "#ffffff";

      hold += `<span class="pitch-container" style="color:${color};">`;
      for (let i = 0; i < kana.length; i++) {
        if (pattern[i] === "0") {
          hold += `<span class="pitch-low">`;
          hold += `<span class="pitch-char">${kana[i]}</span>`;
          hold += `<span class="pitch-line"></span>`;
          hold += `</span>`;
        } else if (pattern[i] === "1") {
          hold += `<span class="pitch-high">`;
          hold += `<span class="pitch-char">${kana[i]}</span>`;
          hold += `<span class="pitch-line"></span>`;
          hold += `</span>`;
        } else if (pattern[i] === "2") {
          hold += `<span class="pitch-to-drop">`;
          hold += `<span class="pitch-char">${kana[i]}</span>`;
          hold += `<span class="pitch-line"></span>`;
          hold += `</span>`;
        } else {
          console.error(
            "pattern[i] found undefined value. pattern is",
            pattern
          );
        }
      }
      hold += `</span>`;
    }

    pitch.innerHTML += hold;
    pitchTags.innerHTML = holdTags;
  }

  function createDefinition(dictNames) {
    const mainDefContainer = document.querySelector("#main-def");
    const fullDefContainer = document.querySelector("#full-def");
    const liEntries = fullDefContainer.querySelectorAll("ol > li");
    const divEntry = fullDefContainer.querySelectorAll("div");
    const ignoredDictNames = ["Nico/Pixiv"];
    const allEntries = liEntries.length > 0 ? liEntries : divEntry;

    const filteredEntries = Array.from(allEntries).filter((dictEntry) => {
      return !ignoredDictNames.some((ignoredDictName) =>
        dictEntry.textContent
          .toLowerCase()
          .includes(ignoredDictName.toLowerCase())
      );
    });

    let dictEntries = [];

    for (const dictName of dictNames) {
      dictEntries = Array.from(filteredEntries).filter((dictEntry) =>
        dictEntry.textContent.toLowerCase().includes(dictName)
      );
      if (dictEntries.length > 0) {
        break;
      }
    }

    if (dictEntries.length === 0) {
      const span = document.createElement("span");
      span.innerText = "No definition found";
      return span;
    }

    if (!dictEntries[0].innerText.toLowerCase().includes("jmdict")) {
      // For non-JMdict dicts
      const selectedEntry = dictEntries[0];
      const monoDefContainer = document.createElement("div");
      monoDefContainer.classList.add("mono-def");

      const textContainer = document.createElement("div");
      textContainer.classList.add("text-container");
      const imagesContainer = document.createElement("div");
      imagesContainer.classList.add("images-container");

      const ul = selectedEntry.querySelector(":scope > ul");
      const minImageWidthEm = 131;
      if (ul !== null) {
        const [definitionItem, ...otherItems] = ul.querySelectorAll("li");
        const cleanedElement = cleanMonoDef(definitionItem);
        textContainer.innerHTML = cleanedElement.innerHTML;
        otherItems.forEach((item) => {
          item.querySelectorAll("a > span > img").forEach((img) => {
            let width = parseFloat(
              img.parentNode.style.width.replace("em", "")
            );
            if (width > minImageWidthEm) {
              const image = document.createElement("img");
              image.src = img.src;
              imagesContainer.appendChild(image);
            }
          });
        });
      } else {
        const cleanedElement = cleanMonoDef(selectedEntry);
        textContainer.innerHTML = cleanedElement.innerHTML;
        textContainer.querySelectorAll("a > span > img").forEach((img) => {
          let width = parseFloat(img.parentNode.style.width.replace("em", ""));
          if (width > minImageWidthEm) {
            const image = document.createElement("img");
            const anchor = img.closest("a");
            image.src = img.src;
            imagesContainer.appendChild(image);
            anchor.parentNode.removeChild(anchor);
          }
        });
      }
      monoDefContainer.appendChild(textContainer);
      monoDefContainer.appendChild(imagesContainer);
      return monoDefContainer;
    } else {
      // For JMdict
      const jmdictDefContainer = document.createElement("div");
      jmdictDefContainer.classList.add("jmdict-def");
      let newHtml = dictEntries
        .map((dictEntry) => {
          const ul = dictEntry.querySelector("ul");
          if (ul !== null) {
            return dictEntries.length > 1
              ? `<li>${ul.outerHTML}</li>`
              : ul.outerHTML;
          } else {
            const innerText = Array.from(dictEntry.childNodes)
              .filter((node) => node.nodeType === Node.TEXT_NODE)
              .map((node) => node.textContent.trim())
              .join(" ");
            return dictEntries.length > 1 ? `<li>${innerText}</li>` : innerText;
          }
        })
        .join("");
      if (dictEntries.length > 1) {
        newHtml = `<ol>${newHtml}</ol>`;
      }
      jmdictDefContainer.innerHTML = newHtml;
      return jmdictDefContainer;
    }
  }

  function cleanMonoDef(element, options = {}) {
    const {
      removeDictName = true,
      removeHeadword = true,
      pixivOnlySummary = true,
    } = options;
    let cleanedElement = element.cloneNode(true);

    const headwordSpan = cleanedElement.querySelector(
      "span[data-sc-name='見出部']"
    );
    const navHeader = cleanedElement.querySelector(
      "span[data-sc-pixiv='nav-header']"
    );
    const mainSpan = cleanedElement.querySelector(":scope > span");
    if (headwordSpan !== null) {
      removeDictName
        ? (cleanedElement.querySelector(":scope > i").style.display = "none")
        : null;
      removeHeadword ? (headwordSpan.style.display = "none") : null;
    } else if (navHeader !== null) {
      removeDictName
        ? (cleanedElement.querySelector(":scope > i").style.display = "none")
        : null;
      removeHeadword ? (navHeader.style.display = "none") : null;
      const pixivSummary = cleanedElement.querySelector(
        "div[data-sc-pixiv='summary']"
      );
      cleanedElement.innerHTML = pixivOnlySummary
        ? pixivSummary.innerHTML
        : cleanedElement.innerHTML;
    } else if (mainSpan !== null) {
      const regex = /(<span\b[^>]*>)(.*?)(<br>|<div>)/;
      const matchResult = cleanedElement.innerHTML.match(regex);
      removeDictName
        ? (cleanedElement.querySelector(":scope > i").style.display = "none")
        : null;
      const headword = removeHeadword ? "" : "$2";
      const breakOrDiv =
        removeHeadword &&
        removeDictName &&
        matchResult &&
        matchResult[3] === "<br>"
          ? ""
          : "$3";
      cleanedElement.innerHTML = cleanedElement.innerHTML.replace(
        regex,
        `$1${headword}${breakOrDiv}`
      );
    } else {
      const regex = /(<i>.*?<\/i>)(.*?)(<br>)/;
      const dictName = removeDictName ? "" : "$1";
      const headword = removeHeadword ? "" : "$2";
      const breakTag = removeHeadword && removeDictName ? "" : "$3";
      cleanedElement.innerHTML = cleanedElement.innerHTML.replace(
        regex,
        `${dictName}${headword}${breakTag}`
      );
    }

    const regex = /(<br>筆順：<br>)(<a[^>]*>.*<\/a>)<br>/g;
    cleanedElement.innerHTML = cleanedElement.innerHTML.replace(regex, "");
    if (
      cleanedElement.firstChild &&
      cleanedElement.firstChild.tagName === "BR"
    ) {
      cleanedElement.removeChild(cleanedElement.firstChild);
    }
    if (
      cleanedElement.firstChild &&
      cleanedElement.firstChild.firstChild &&
      cleanedElement.firstChild.firstChild.tagName === "BR"
    ) {
      cleanedElement.firstChild.removeChild(
        cleanedElement.firstChild.firstChild
      );
    }

    return cleanedElement;
  }

  function initialize() {
    paintTargetWord();
    constructPitch();
    tweakHTML();
    const mainDefContainer = document.getElementById("main-def");
    if (mainDefContainer.innerHTML === "") {
      let dictNames = [
        "jmdict",
        "pixiv",
        "実用日本語表現辞典",
        "三省堂国語辞典",
        "旺文社国語辞典",
        "明鏡国語辞典",
        "大辞林",
        "新明解国語辞典",
        "デジタル大辞泉",
        "広辞苑",
      ];
      mainDefContainer.appendChild(createDefinition(dictNames));
    }
  }

  window.onload = initialize();
</script>
